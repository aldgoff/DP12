1. System can handle four types of plastics: (domain: order["plastic"])
	1.1 ABS
	1.2 Polypropylene
	1.3 Polyethelene
	1.4 PET
	1.5 If the plastic is unknown, default to ABS
		1.5.1 cout << "  <>Unknown plastic |<unknown plastic>| defaulting to 'ABS'.\n";
2. Handle orders upto 50,000: (domain: order["size"])
	1.1 If no size specified, default to 100 (a pilot run)
		1.1.1 cout << "  <>No size specified, defaulting to 100.\n";
	1.2 If size > 50,000, default to 50,000
		1.2.1 cout << "  <>Size exceeds mold lifetime |100000| defaulting to MediumOrder of 50000.\n";
3. Implement the following three Packagers: (domain: order["packager"])
	3.1 Bulk (default, just dump part to output bin)
	3.2 ShrinkWrap
	3.3 HardPack
	3.4 If Packager unknown, default to Bulk (none)
		3.4.1 cout << "  <>Unknown packager |<unknown packager>| defaulting to 'None'.\n";
4. Support three injection molding machines: (domain: size)
	4.1 IJM_110 - good for aluminum molds with 1 cavity
	4.2 IJM_120 - good for aluminum molds with 2 cavities
	4.3 IJM_210 - good for steel molds with 1 cavity
5. Support two mold metals: (domain: size)
	5.1 Aluminum
	5.2 Stainless steel
6. Support molds with multiple cavities: (domain: size)
	6.1 1
	6.2 2
7. Support two conveyer belts: (domain: cavities)
	7.1 Linear
	7.2 Y-Split
8. Support two output bins: (domain: size)
	8.1 CardboarBox
	8.2 PallotBox
		8.2.1 Default to largest if size > max
9. Setup the injection line: (domains: order size, cavities, and Packager)
	9.1 cout << "  Setup injection line for <size> order with <Packager> packager:\n";
	9.2 size <= 10,000: cout << "    IJM_110 - Aluminum(1) - Linear conveyer belt - CardboardBox.\n";
	9.2 size <= 20,000: cout << "    IJM_120 - Aluminum(2) - Y-Split conveyer belt - ShellBox.\n";
	9.2 size <= 50,000: cout << "    IJM_210 - Steel(1) - Linear conveyer belt - PallotBox.\n";

10. Process order: (doman: order[...])
	10.1 Get mold
	10.2 Insert tags into mold
	10.3 Load plastic, color die, and additive bins
	10.4 Simulate cycling the IJM for the specified plastic <size> times
		10.4.1 Just once, specify the injection cycle (depends on plastic type)
		10.4.2 Just once, simulate a full parts bin asking upline machines to pause
	10.5 Clean the mold (ignore molds that are used up, clean them all)

11. Support three mold shapes with specified volumes in cc: (domain: mold)
	11.1 duck (35 cc)
		11.1.1 Default: cout << "    <>Unknown mold |<mold>| defaulting to 'duck'.\n";
	11.2 car (40 cc)
	11.3 hero (50 cc)
12. Molds are be pulled fron inventory or milled from bulk metal: (domain: moldLoc)
	12.1 (To keep the final simple, the order will specify the mold location.)
		12.1.1 If location and shape unknown, default to duck from inventory
		12.1.2 cout << "    <>Can't find place |<loc>| to get |<shape>| mold from with |<finish>| finish, defaulting to smooth duck from inventory.\n";
	12.2 Inventory:
		12.2.1 cout << "    Pull <shape> mold from inventory.\n";
	12.3 Mill: (must be last option)
		12.3.1 cout << "    Create <shape> mold from mill with <n> cavities - steps: <steps>.\n"
13. Shapes are milled with three techniques (actual steps simulated, see "couts" below):
	13.1 drill
	13.2 cut
	13.3 grind
14. Support three finishes: (domain: finish)
	14.1 smooth (default)
	14.2 rippled
	14.3 dimpled
15. Support three milling platforms: (domains: metal, finish)
	15.1 HighCarbon tools (suitable for aluminum)
		15.1.1 cout << "      using HighCarbon tools (drill, cut, and high speed grind) to mill <metal> block into <n> <shape> shapes with <finish> finish.\n";
	15.2 Carbide tools (suitable for steel)
		15.2.1 rippled: cout << "      using Carbide tools (high speed drill, cross cut, and layer grind) to mill <metal> block into <n> <shape> shapes with <finish> finish.\n";
	15.3 Diamond tipped (suitable for steel) (default)
		15.3.1 dimpled: cout << "      using DiamondTipped tools (precision drill, oil cooled cut, and cartoid grind) to mill steel block into 1 hero shape with dimpled finish.\n";
16. Support three tags (+ Blank), widths in mm (inserted into molds, typically under the support base, think plastic toy): (domain: tags)
	16.0 Blank (width determined by cavity space & sum of other tags' widths)
	16.1 ModelNumber (2 mm)
	16.2 Country (2 mm)
	16.3 Date (2 mm)
	16.4 Ignore each and every unknown tag
		16.4.1 cout << "    Ignoring unknown tag <tag>.\n"
	16.5 Total space for tags is 20 mm
		16.5.1 cout << "    Insert tags [space separated list of tags] of width <n>/20 mm, blank tag is <20-n> mm.\n";
17. Support three additives, the order specifies the volume in cc: (domains: order[<additive> <vol>])
	17.1 UVInhibiter
	17.2 AntiBacterial
	17.3 Hydrophilic
18. Support six colors (assume volume is 10% of shape, & die independent of plastic type): (domain: color)
	18.0 black
	18.1 brown
	18.2 red
	18.3 orange
	18.4 yellow
	18.5 green
	18.6 If no color specified, default to clear (no color additive).
19. Simulate mixing plastic, color, and additives with volume recipe & total (account for multiple cavities):
	19.1 cout << "    Load plastic bin with <plastic> and color bin with <color>.\n";
	19.2 cout << "      Recipe: <plastic>(<vol>) <color>(<vol>) <additive1>(<vol>)... = <shape vol> cc.\n";
	19.3 cout << "      Volume: <shape>(<shape vol>) * <cavities> cavities = <total vol> cc.\n";

20. Support three injection cycles: (domain: plastic)
	20.1 ABS:  heat to 440 - inject at 125 PSI - cool to 360 - progressive eject
	20.2 Poly: heat to 350 - inject at  90 PSI - cool to 290 - smooth eject
	20.3 PET:  heat to 404 - inject at 110 PSI - cool to 340 - smooth eject
21. Support three upline machines pausing when package/output/parts bin is full:
	21.1 IJM
	21.2 Conveyer belt
	21.3 Packager
	21.4 Note: (The example output file is a little weak here, done more correctly, the diffs will be off a little.)
22. Simulate cycling the IJM for the specified plastic times
	22.1 cout << "    Cycle IJM for <plastic> <size> times.\n";
	22.2 cout << "      Close - heat to <temp> - inject at <psi> PSI - cool to <temp> - separate - <technique> eject.\n";
	22.3 cout << "      <PackageBin> package bin full...\n";
	22.3.1 cout << "        IJM pausing while <PackageBin> package bin is swapped.\n";
	22.3.2 cout << "        Conveyer belt pausing while <PackageBin> package bin is swapped.\n";
	22.3.3 cout << "        Packager pausing while <PackageBin> package bin is swapped.\n";

23. Clean the molds, depends on plastic and metal:
	23.1 Use existing cleaning methods (see namespace legacy)
	23.2 cout << "    Clean <plastic> <optional metal> mold: <cleaning steps>.\n";

24. Instrument the destructors:
	24.1 cout << "~<ClassName> ";
	24.2 Use newlines to logically group the class heirarchies
	24.3 Classes may be suffixed with design pattern name/abbreviation and/or presentation order

25. To get the diffs to zero:
	25.1 In main(int argc, char* args[]):
		25.1.1 cout << "Hello DP4.\n" << endl;
		25.1.2 final_design_file::demo(string(args[1]));	// Pass in the input file (orders_1.txt).
		25.1.3 cout << "Aloha DP4.\n";
		